/**
 * UUID Redirect Handler
 *
 * This component handles redirects from old UUID-based URLs to new pathname-based URLs.
 * Place this in your episode/[slug]/page.tsx to handle both old and new URL formats.
 */

import { redirect } from "next/navigation";
import { groq } from "next-sanity";
import { loadQuery } from "../../../../../data/sanity/loadQuery";

interface EpisodeRedirectData {
  _id: string;
  uuid?: string;
  pathname?: {
    current?: string;
  };
  youtube?: {
    uuid?: string;
  };
}

const EPISODE_REDIRECT_QUERY = groq`
  *[_type == "episode" && (
    uuid == $identifier || 
    youtube.uuid == $identifier ||
    pathname.current == $identifier
  )][0] {
    _id,
    uuid,
    pathname,
    youtube {
      uuid
    }
  }
`;

/**
 * Checks if a slug is a UUID format and handles redirects
 */
export async function handleEpisodeRedirect(slug: string) {
  // Check if slug looks like a UUID (old format)
  const isUuidFormat = /^[0-9]+-[0-9]+-?[0-9]*$/.test(slug);

  // If it's not UUID format and starts with /episode/, it's already a pathname
  if (!isUuidFormat && slug.startsWith("/episode/")) {
    return null; // No redirect needed
  }

  // Fetch episode data to determine if redirect is needed
  const { data: episode } = await loadQuery<EpisodeRedirectData>({
    query: EPISODE_REDIRECT_QUERY,
    params: { identifier: isUuidFormat ? slug : `/episode/${slug}` },
  });

  if (!episode) {
    return null; // Episode not found, let 404 handle it
  }

  // If we found the episode by UUID, redirect to pathname
  if (isUuidFormat && episode.pathname?.current) {
    redirect(episode.pathname.current);
  }

  // If pathname doesn't exist but UUID does, this episode needs migration
  if (!episode.pathname?.current && (episode.uuid || episode.youtube?.uuid)) {
    console.warn(
      `Episode ${episode._id} found by UUID but has no pathname - needs migration`
    );
    return episode; // Return data anyway, but log warning
  }

  return episode;
}

/**
 * Enhanced episode page that handles both UUID and pathname routing
 */
export default async function EpisodePage({
  params,
}: {
  params: Promise<{ slug: string }>;
}) {
  const { slug } = await params;

  // Handle potential redirects
  const episode = await handleEpisodeRedirect(slug);

  if (!episode) {
    // This will trigger the not-found page
    return null;
  }

  // Your existing episode page component logic here
  return <div>{/* Your episode content */}</div>;
}

/**
 * Static redirect map (generated by migration script)
 * Use this as a fallback if database lookup fails
 */
export const UUID_TO_PATHNAME_REDIRECTS: Record<string, string> = {
  // This will be populated by the migration script output
  // Example:
  // "401-1": "/episode/business-leadership-strategies",
  // "401-2": "/episode/business-leadership-strategies-2",
};

/**
 * Fallback redirect using static map
 */
export function getStaticRedirect(uuid: string): string | null {
  return UUID_TO_PATHNAME_REDIRECTS[uuid] || null;
}
