{"version":3,"file":"parseBody.cjs","sources":["../../src/webhook/parseBody.ts"],"sourcesContent":["import type {SanityDocument} from '@sanity/types'\nimport {isValidSignature, SIGNATURE_HEADER_NAME} from '@sanity/webhook'\nimport type {NextApiRequest} from 'next'\nimport type {NextRequest} from 'next/server'\n\nimport {_readBody as readBody} from './readBody'\n\n/** @public */\nexport type ParsedBody<T> = {\n  /**\n   * If a secret is given then it returns a boolean. If no secret is provided then no validation is done on the signature, and it'll return `null`\n   */\n  isValidSignature: boolean | null\n  body: T | null\n}\n\n/**\n * @deprecated Use `ParsedBody` instead\n * @public\n */\nexport type ParseBody<Body = SanityDocument> = ParsedBody<Body>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\nexport async function parseBody<Body = SanityDocument>(\n  req: NextApiRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency?: boolean,\n): Promise<ParsedBody<Body>>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\nexport async function parseBody<Body = SanityDocument>(\n  req: NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency?: boolean,\n): Promise<ParsedBody<Body>>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\n// eslint-disable-next-line require-await\nexport async function parseBody<Body = SanityDocument>(\n  req: NextApiRequest | NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  // @ts-expect-error -- add global typings for EdgeRuntime\n  if (typeof EdgeRuntime !== 'undefined') {\n    throw new TypeError(\n      `The edge runtime isn't supported. You'll have to use the 'nodejs' runtime until the underlying \\`@sanity/webhook\\` package is updated to support it.`,\n    )\n  }\n  return 'text' in req\n    ? parseAppBody(req, secret, waitForContentLakeEventualConsistency)\n    : parsePageBody(req, secret, waitForContentLakeEventualConsistency)\n}\n\nasync function parsePageBody<Body = SanityDocument>(\n  req: NextApiRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  let signature = req.headers[SIGNATURE_HEADER_NAME]\n  if (Array.isArray(signature)) {\n    signature = signature[0]\n  }\n  if (!signature) {\n    console.error('Missing signature header')\n    return {body: null, isValidSignature: null}\n  }\n\n  if (req.readableEnded) {\n    throw new Error(\n      `Request already ended and the POST body can't be read. Have you setup \\`export {config} from 'next-sanity/webhook' in your webhook API handler?\\``,\n    )\n  }\n\n  const body = await readBody(req)\n  const validSignature = secret ? isValidSignature(body, signature, secret.trim()) : null\n\n  if (validSignature !== false && waitForContentLakeEventualConsistency) {\n    await new Promise((resolve) => setTimeout(resolve, 1000))\n  }\n\n  return {\n    body: body.trim() ? JSON.parse(body) : null,\n    isValidSignature: validSignature,\n  }\n}\n\n/**\n * @deprecated Use `ParsedBody` instead\n * @public\n */\nexport type ParseAppBody<Body = SanityDocument> = ParsedBody<Body>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @deprecated Use `parseBody` instead\n * @public\n */\nexport async function parseAppBody<Body = SanityDocument>(\n  req: NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  const signature = req.headers.get(SIGNATURE_HEADER_NAME)!\n  if (!signature) {\n    console.error('Missing signature header')\n    return {body: null, isValidSignature: null}\n  }\n\n  const body = await req.text()\n  const validSignature = secret ? isValidSignature(body, signature, secret.trim()) : null\n\n  if (validSignature !== false && waitForContentLakeEventualConsistency) {\n    await new Promise((resolve) => setTimeout(resolve, 1000))\n  }\n\n  return {\n    body: body.trim() ? JSON.parse(body) : null,\n    isValidSignature: validSignature,\n  }\n}\n"],"names":["signature","console","body","isValidSignature"],"mappings":";;;;;;;;AA+CA;AAI6B;AAEvB;AACF;AAGF;;AAIF;AAEA;AAI6B;;AAEvB;AACFA;AACF;;AAEEC;;AACQC;AAAYC;;AACtB;;AAGE;AAGF;;AAGM;AAEF;;AAEJ;;AAGED;AACAC;;AAEJ;AAaA;AAI6B;;;AAGzBF;;AACQC;AAAYC;;AACtB;AAEM;AACA;AAEF;;AAEJ;;AAGED;AACAC;;AAEJ;;"}