{"version":3,"file":"parseBody.cjs","sources":["../../src/webhook/parseBody.ts"],"sourcesContent":["import type {SanityDocument} from '@sanity/types'\nimport {isValidSignature, SIGNATURE_HEADER_NAME} from '@sanity/webhook'\nimport type {NextApiRequest} from 'next'\nimport type {NextRequest} from 'next/server'\n\nimport {_readBody as readBody} from './readBody'\n\n/** @public */\nexport type ParsedBody<T> = {\n  /**\n   * If a secret is given then it returns a boolean. If no secret is provided then no validation is done on the signature, and it'll return `null`\n   */\n  isValidSignature: boolean | null\n  body: T | null\n}\n\n/**\n * @deprecated Use `ParsedBody` instead\n * @public\n */\nexport type ParseBody<Body = SanityDocument> = ParsedBody<Body>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\nexport async function parseBody<Body = SanityDocument>(\n  req: NextApiRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency?: boolean,\n): Promise<ParsedBody<Body>>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\nexport async function parseBody<Body = SanityDocument>(\n  req: NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency?: boolean,\n): Promise<ParsedBody<Body>>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\n// eslint-disable-next-line require-await\nexport async function parseBody<Body = SanityDocument>(\n  req: NextApiRequest | NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  // @ts-expect-error -- add global typings for EdgeRuntime\n  if (typeof EdgeRuntime !== 'undefined') {\n    throw new TypeError(\n      `The edge runtime isn't supported. You'll have to use the 'nodejs' runtime until the underlying \\`@sanity/webhook\\` package is updated to support it.`,\n    )\n  }\n  return 'text' in req\n    ? parseAppBody(req, secret, waitForContentLakeEventualConsistency)\n    : parsePageBody(req, secret, waitForContentLakeEventualConsistency)\n}\n\nasync function parsePageBody<Body = SanityDocument>(\n  req: NextApiRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  let signature = req.headers[SIGNATURE_HEADER_NAME]\n  if (Array.isArray(signature)) {\n    signature = signature[0]\n  }\n  if (!signature) {\n    console.error('Missing signature header')\n    return {body: null, isValidSignature: null}\n  }\n\n  if (req.readableEnded) {\n    throw new Error(\n      `Request already ended and the POST body can't be read. Have you setup \\`export {config} from 'next-sanity/webhook' in your webhook API handler?\\``,\n    )\n  }\n\n  const body = await readBody(req)\n  const validSignature = secret ? isValidSignature(body, signature, secret.trim()) : null\n\n  if (validSignature !== false && waitForContentLakeEventualConsistency) {\n    await new Promise((resolve) => setTimeout(resolve, 1000))\n  }\n\n  return {\n    body: body.trim() ? JSON.parse(body) : null,\n    isValidSignature: validSignature,\n  }\n}\n\n/**\n * @deprecated Use `ParsedBody` instead\n * @public\n */\nexport type ParseAppBody<Body = SanityDocument> = ParsedBody<Body>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @deprecated Use `parseBody` instead\n * @public\n */\nexport async function parseAppBody<Body = SanityDocument>(\n  req: NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  const signature = req.headers.get(SIGNATURE_HEADER_NAME)!\n  if (!signature) {\n    console.error('Missing signature header')\n    return {body: null, isValidSignature: null}\n  }\n\n  const body = await req.text()\n  const validSignature = secret ? isValidSignature(body, signature, secret.trim()) : null\n\n  if (validSignature !== false && waitForContentLakeEventualConsistency) {\n    await new Promise((resolve) => setTimeout(resolve, 1000))\n  }\n\n  return {\n    body: body.trim() ? JSON.parse(body) : null,\n    isValidSignature: validSignature,\n  }\n}\n"],"names":["parseBody","req","secret","waitForContentLakeEventualConsistency","arguments","length","undefined","EdgeRuntime","TypeError","parseAppBody","parsePageBody","signature","headers","SIGNATURE_HEADER_NAME","Array","isArray","console","error","body","isValidSignature","readableEnded","Error","readBody","validSignature","trim","Promise","resolve","setTimeout","JSON","parse","get","text"],"mappings":";;;;;;;AA+CA,eAAsBA,SACpBA,CAAAC,GAAA,EACAC,MACA,EAC2B;EAAA,IAD3BC,qCAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAiD,IACtB;EAEvB,IAAA,OAAOG,gBAAgB,WAAa,EAAA;IACtC,MAAM,IAAIC,SAAA,CACR,oJAAA,CACF;EACF;EACO,OAAA,MAAA,IAAUP,GACb,GAAAQ,YAAA,CAAaR,GAAK,EAAAC,MAAA,EAAQC,qCAAqC,CAC/D,GAAAO,aAAA,CAAcT,GAAK,EAAAC,MAAA,EAAQC,qCAAqC,CAAA;AACtE;AAEA,eAAeO,aACbA,CAAAT,GAAA,EACAC,MACA,EAC2B;EAAA,IAD3BC,qCAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAiD,IACtB;EACvB,IAAAO,SAAA,GAAYV,GAAI,CAAAW,OAAA,CAAQC,OAAqB,CAAAA,qBAAA,CAAA;EAC7C,IAAAC,KAAA,CAAMC,OAAQ,CAAAJ,SAAS,CAAG,EAAA;IAC5BA,SAAA,GAAYA,UAAU,CAAC,CAAA;EACzB;EACA,IAAI,CAACA,SAAW,EAAA;IACdK,OAAA,CAAQC,MAAM,0BAA0B,CAAA;IACxC,OAAO;MAACC,IAAA,EAAM,IAAM;MAAAC,gBAAA,EAAkB;IAAI,CAAA;EAC5C;EAEA,IAAIlB,IAAImB,aAAe,EAAA;IACrB,MAAM,IAAIC,KAAA,CACR,iJAAA,CACF;EACF;EAEM,MAAAH,IAAA,GAAO,MAAMI,kBAAA,CAASrB,GAAG,CAAA;EACzB,MAAAsB,cAAA,GAAiBrB,SAASiB,OAAAA,CAAAA,gBAAiB,CAAAD,IAAA,EAAMP,WAAWT,MAAO,CAAAsB,IAAA,EAAM,CAAI,GAAA,IAAA;EAE/E,IAAAD,cAAA,KAAmB,SAASpB,qCAAuC,EAAA;IACrE,MAAM,IAAIsB,OAAQ,CAACC,WAAYC,UAAW,CAAAD,OAAA,EAAS,GAAI,CAAC,CAAA;EAC1D;EAEO,OAAA;IACLR,MAAMA,IAAK,CAAAM,IAAA,KAASI,IAAK,CAAAC,KAAA,CAAMX,IAAI,CAAI,GAAA,IAAA;IACvCC,gBAAkB,EAAAI;EAAA,CACpB;AACF;AAaA,eAAsBd,YACpBA,CAAAR,GAAA,EACAC,MACA,EAC2B;EAAA,IAD3BC,qCAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAiD,IACtB;EAC3B,MAAMO,SAAY,GAAAV,GAAA,CAAIW,OAAQ,CAAAkB,GAAA,CAAIjB,OAAqB,CAAAA,qBAAA,CAAA;EACvD,IAAI,CAACF,SAAW,EAAA;IACdK,OAAA,CAAQC,MAAM,0BAA0B,CAAA;IACxC,OAAO;MAACC,IAAA,EAAM,IAAM;MAAAC,gBAAA,EAAkB;IAAI,CAAA;EAC5C;EAEM,MAAAD,IAAA,GAAO,MAAMjB,GAAA,CAAI8B,IAAK,EAAA;EACtB,MAAAR,cAAA,GAAiBrB,SAASiB,OAAAA,CAAAA,gBAAiB,CAAAD,IAAA,EAAMP,WAAWT,MAAO,CAAAsB,IAAA,EAAM,CAAI,GAAA,IAAA;EAE/E,IAAAD,cAAA,KAAmB,SAASpB,qCAAuC,EAAA;IACrE,MAAM,IAAIsB,OAAQ,CAACC,WAAYC,UAAW,CAAAD,OAAA,EAAS,GAAI,CAAC,CAAA;EAC1D;EAEO,OAAA;IACLR,MAAMA,IAAK,CAAAM,IAAA,KAASI,IAAK,CAAAC,KAAA,CAAMX,IAAI,CAAI,GAAA,IAAA;IACvCC,gBAAkB,EAAAI;EAAA,CACpB;AACF;;"}