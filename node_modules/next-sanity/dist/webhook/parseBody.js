import { isValidSignature, SIGNATURE_HEADER_NAME } from '@sanity/webhook';
import { _readBody } from './readBody.js';
async function parseBody(req, secret) {
  let waitForContentLakeEventualConsistency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  if (typeof EdgeRuntime !== "undefined") {
    throw new TypeError("The edge runtime isn't supported. You'll have to use the 'nodejs' runtime until the underlying `@sanity/webhook` package is updated to support it.");
  }
  return "text" in req ? parseAppBody(req, secret, waitForContentLakeEventualConsistency) : parsePageBody(req, secret, waitForContentLakeEventualConsistency);
}
async function parsePageBody(req, secret) {
  let waitForContentLakeEventualConsistency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  let signature = req.headers[SIGNATURE_HEADER_NAME];
  if (Array.isArray(signature)) {
    signature = signature[0];
  }
  if (!signature) {
    console.error("Missing signature header");
    return {
      body: null,
      isValidSignature: null
    };
  }
  if (req.readableEnded) {
    throw new Error("Request already ended and the POST body can't be read. Have you setup `export {config} from 'next-sanity/webhook' in your webhook API handler?`");
  }
  const body = await _readBody(req);
  const validSignature = secret ? isValidSignature(body, signature, secret.trim()) : null;
  if (validSignature !== false && waitForContentLakeEventualConsistency) {
    await new Promise(resolve => setTimeout(resolve, 1e3));
  }
  return {
    body: body.trim() ? JSON.parse(body) : null,
    isValidSignature: validSignature
  };
}
async function parseAppBody(req, secret) {
  let waitForContentLakeEventualConsistency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  const signature = req.headers.get(SIGNATURE_HEADER_NAME);
  if (!signature) {
    console.error("Missing signature header");
    return {
      body: null,
      isValidSignature: null
    };
  }
  const body = await req.text();
  const validSignature = secret ? isValidSignature(body, signature, secret.trim()) : null;
  if (validSignature !== false && waitForContentLakeEventualConsistency) {
    await new Promise(resolve => setTimeout(resolve, 1e3));
  }
  return {
    body: body.trim() ? JSON.parse(body) : null,
    isValidSignature: validSignature
  };
}
export { parseAppBody, parseBody };
//# sourceMappingURL=parseBody.js.map
