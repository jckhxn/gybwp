{"version":3,"file":"index.js","sources":["../src/errors.ts","../src/signature.ts","../src/middleware.ts"],"sourcesContent":["export type WebhookSignatureError = WebhookSignatureValueError | WebhookSignatureFormatError\n\nexport class WebhookSignatureValueError extends Error {\n  public type = 'WebhookSignatureValueError'\n  public statusCode = 401\n}\n\nexport class WebhookSignatureFormatError extends Error {\n  public type = 'WebhookSignatureFormatError'\n  public statusCode = 400\n}\n\nexport function isSignatureError(error: unknown): error is WebhookSignatureError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    'type' in error &&\n    ['WebhookSignatureValueError', 'WebhookSignatureFormatError'].includes(\n      (error as WebhookSignatureError).type\n    )\n  )\n}\n","import crypto from 'crypto'\nimport base64Url from 'base64url'\nimport {WebhookSignatureFormatError, WebhookSignatureValueError} from './errors'\nimport type {DecodedSignature, ConnectLikeRequest} from './types'\n\n/**\n * We didn't send signed payloads prior to 2021 (2021-01-01T00:00:00.000Z)\n */\nconst MINIMUM_TIMESTAMP = 1609459200000\n\nconst SIGNATURE_HEADER_REGEX = /^t=(\\d+)[, ]+v1=([^, ]+)$/\n\nexport const SIGNATURE_HEADER_NAME = 'sanity-webhook-signature'\n\nexport function assertValidSignature(\n  stringifiedPayload: string,\n  signature: string,\n  secret: string\n): void {\n  const {timestamp} = decodeSignatureHeader(signature)\n  const encoded = encodeSignatureHeader(stringifiedPayload, timestamp, secret)\n  if (signature !== encoded) {\n    throw new WebhookSignatureValueError('Signature is invalid')\n  }\n}\n\nexport function isValidSignature(\n  stringifiedPayload: string,\n  signature: string,\n  secret: string\n): boolean {\n  try {\n    assertValidSignature(stringifiedPayload, signature, secret)\n    return true\n  } catch (err) {\n    return false\n  }\n}\n\nexport function assertValidRequest(request: ConnectLikeRequest, secret: string): void {\n  const signature = request.headers[SIGNATURE_HEADER_NAME]\n  if (Array.isArray(signature)) {\n    throw new WebhookSignatureFormatError('Multiple signature headers received')\n  }\n\n  if (typeof signature !== 'string') {\n    throw new WebhookSignatureValueError('Request contained no signature header')\n  }\n\n  if (typeof request.body === 'undefined') {\n    throw new WebhookSignatureFormatError('Request contained no parsed request body')\n  }\n\n  if (typeof request.body === 'string' || Buffer.isBuffer(request.body)) {\n    assertValidSignature(request.body.toString('utf8'), signature, secret)\n  } else {\n    throw new Error(\n      '[@sanity/webhook] `request.body` was not a string/buffer - this can lead to invalid signatures. See the [migration docs](https://github.com/sanity-io/webhook-toolkit#from-parsed-to-unparsed-body) for details on how to fix this.'\n    )\n  }\n}\n\nexport function isValidRequest(request: ConnectLikeRequest, secret: string): boolean {\n  try {\n    assertValidRequest(request, secret)\n    return true\n  } catch (err) {\n    return false\n  }\n}\n\nexport function encodeSignatureHeader(\n  stringifiedPayload: string,\n  timestamp: number,\n  secret: string\n): string {\n  const signature = createHS256Signature(stringifiedPayload, timestamp, secret)\n  return `t=${timestamp},v1=${signature}`\n}\n\nexport function decodeSignatureHeader(signaturePayload: string): DecodedSignature {\n  if (!signaturePayload) {\n    throw new WebhookSignatureFormatError('Missing or empty signature header')\n  }\n\n  const [, timestamp, hashedPayload] = signaturePayload.trim().match(SIGNATURE_HEADER_REGEX) || []\n  if (!timestamp || !hashedPayload) {\n    throw new WebhookSignatureFormatError('Invalid signature payload format')\n  }\n\n  return {\n    timestamp: parseInt(timestamp, 10),\n    hashedPayload,\n  }\n}\n\nfunction createHS256Signature(\n  stringifiedPayload: string,\n  timestamp: number,\n  secret: string\n): string {\n  if (!secret || typeof secret !== 'string') {\n    throw new WebhookSignatureFormatError('Invalid secret provided')\n  }\n\n  if (!stringifiedPayload) {\n    throw new WebhookSignatureFormatError('Can not create signature for empty payload')\n  }\n\n  if (typeof stringifiedPayload !== 'string') {\n    throw new WebhookSignatureFormatError('Payload must be a JSON-encoded string')\n  }\n\n  if (typeof timestamp !== 'number' || isNaN(timestamp) || timestamp < MINIMUM_TIMESTAMP) {\n    throw new WebhookSignatureFormatError(\n      'Invalid signature timestamp, must be a unix timestamp with millisecond precision'\n    )\n  }\n\n  const hmac = crypto.createHmac('sha256', secret)\n  const signaturePayload = `${timestamp}.${stringifiedPayload}`\n  const signature = hmac.update(signaturePayload, 'utf8').digest()\n  return base64Url(signature)\n}\n","import type {RequestHandler} from 'express'\nimport {isSignatureError} from './errors'\nimport {assertValidRequest} from './signature'\n\nexport interface SignatureMiddlewareOptions {\n  secret: string\n  parseBody?: boolean\n  respondOnError?: boolean\n}\n\nexport function requireSignedRequest(options: SignatureMiddlewareOptions): RequestHandler {\n  const parseBody = typeof options.parseBody === 'undefined' ? true : options.parseBody\n  const respondOnError =\n    typeof options.respondOnError === 'undefined' ? true : options.respondOnError\n\n  return function ensureSignedRequest(request, response, next) {\n    try {\n      assertValidRequest(request, options.secret)\n      if (parseBody && typeof request.body === 'string') {\n        request.body = JSON.parse(request.body)\n      }\n      next()\n    } catch (err) {\n      if (!respondOnError || !isSignatureError(err)) {\n        next(err)\n        return\n      }\n\n      response.status(err.statusCode).json({message: err.message})\n    }\n  }\n}\n"],"names":["WebhookSignatureValueError","Error","type","statusCode","WebhookSignatureFormatError","isSignatureError","error","includes","MINIMUM_TIMESTAMP","SIGNATURE_HEADER_REGEX","SIGNATURE_HEADER_NAME","assertValidSignature","stringifiedPayload","signature","secret","timestamp","decodeSignatureHeader","encoded","encodeSignatureHeader","isValidSignature","err","assertValidRequest","request","headers","Array","isArray","body","Buffer","isBuffer","toString","isValidRequest","createHS256Signature","signaturePayload","hashedPayload","trim","match","parseInt","isNaN","hmac","crypto","default","createHmac","update","digest","base64Url","requireSignedRequest","options","parseBody","respondOnError","ensureSignedRequest","response","next","JSON","parse","status","json","message"],"mappings":"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"}