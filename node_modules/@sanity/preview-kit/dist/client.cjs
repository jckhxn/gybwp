'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var client = require('@sanity/client');
var stega = require('@sanity/client/stega');
var mapToEditLinks$1 = require('./_chunks/mapToEditLinks-vYtU8SXd.cjs');
const createClient = config => {
  var _a, _b;
  const {
    encodeSourceMap = detectEnableSourceMap(),
    encodeSourceMapAtPath,
    studioUrl = detectStudioUrl(),
    logger,
    ...options
  } = config;
  let shouldEncodeSourceMap = encodeSourceMap === true;
  if (encodeSourceMap === "auto") {
    shouldEncodeSourceMap = isVercelPreviewEnvironment();
  }
  if (typeof encodeSourceMap === "string" && encodeSourceMap !== "auto") {
    throw new Error("Invalid value for encodeSourceMap: ".concat(encodeSourceMap, ". Did you mean 'auto'?"));
  }
  try {
    if (shouldEncodeSourceMap && config.resultSourceMap !== false) {
      if (!studioUrl) {
        (_a = logger == null ? void 0 : logger.error) == null ? void 0 : _a.call(logger, "[@sanity/preview-kit]: Content source map enabled client is enabled, but no studioUrl is provided. Falling back to @sanity/client");
        return client.createClient(options);
      }
      (_b = logger == null ? void 0 : logger.debug) == null ? void 0 : _b.call(logger, "[@sanity/preview-kit]: Creating source map enabled client");
      return stega.createClient({
        ...options,
        // Source maps by Content Lake are required in order to know where to insert the encoded source maps into strings
        resultSourceMap: config.resultSourceMap ? config.resultSourceMap : "withKeyArraySelector",
        stega: {
          enabled: true,
          studioUrl,
          logger,
          filter: encodeSourceMapAtPath ? props => encodeSourceMapAtPath({
            path: props.sourcePath,
            filterDefault: () => props.filterDefault(props)
          }) : void 0
        }
      });
    }
  } catch (err) {
    console.error("[@sanity/preview-kit]: Error creating client", err, "falling back to non-embedded sourcemap mode");
  }
  return client.createClient(options);
};
function isVercelPreviewEnvironment() {
  try {
    return undefined.VERCEL_ENV === "preview";
  } catch {}
  try {
    return process.env.VERCEL_ENV === "preview";
  } catch {}
  return false;
}
function detectEnableSourceMap() {
  try {
    return undefined.SANITY_SOURCE_MAP === "true";
  } catch {}
  try {
    return process.env.SANITY_SOURCE_MAP === "true";
  } catch {}
  return false;
}
function detectStudioUrl() {
  try {
    return undefined.SANITY_STUDIO_URL;
  } catch {}
  try {
    return process.env.SANITY_STUDIO_URL;
  } catch {}
}
function mapToEditLinks(response, studioUrl) {
  return mapToEditLinks$1.mapToEditLinks(response.result, response.resultSourceMap, studioUrl);
}
exports.createClient = createClient;
exports.mapToEditLinks = mapToEditLinks;
//# sourceMappingURL=client.cjs.map
