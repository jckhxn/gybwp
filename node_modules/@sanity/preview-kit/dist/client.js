import { createClient as createClient$1 } from '@sanity/client';
import { createClient as createClient$2 } from '@sanity/client/stega';
import { mapToEditLinks as mapToEditLinks$1 } from './_chunks/mapToEditLinks-fgNQo2rd.js';
const createClient = config => {
  var _a, _b;
  const {
    encodeSourceMap = detectEnableSourceMap(),
    encodeSourceMapAtPath,
    studioUrl = detectStudioUrl(),
    logger,
    ...options
  } = config;
  let shouldEncodeSourceMap = encodeSourceMap === true;
  if (encodeSourceMap === "auto") {
    shouldEncodeSourceMap = isVercelPreviewEnvironment();
  }
  if (typeof encodeSourceMap === "string" && encodeSourceMap !== "auto") {
    throw new Error("Invalid value for encodeSourceMap: ".concat(encodeSourceMap, ". Did you mean 'auto'?"));
  }
  try {
    if (shouldEncodeSourceMap && config.resultSourceMap !== false) {
      if (!studioUrl) {
        (_a = logger == null ? void 0 : logger.error) == null ? void 0 : _a.call(logger, "[@sanity/preview-kit]: Content source map enabled client is enabled, but no studioUrl is provided. Falling back to @sanity/client");
        return createClient$1(options);
      }
      (_b = logger == null ? void 0 : logger.debug) == null ? void 0 : _b.call(logger, "[@sanity/preview-kit]: Creating source map enabled client");
      return createClient$2({
        ...options,
        // Source maps by Content Lake are required in order to know where to insert the encoded source maps into strings
        resultSourceMap: config.resultSourceMap ? config.resultSourceMap : "withKeyArraySelector",
        stega: {
          enabled: true,
          studioUrl,
          logger,
          filter: encodeSourceMapAtPath ? props => encodeSourceMapAtPath({
            path: props.sourcePath,
            filterDefault: () => props.filterDefault(props)
          }) : void 0
        }
      });
    }
  } catch (err) {
    console.error("[@sanity/preview-kit]: Error creating client", err, "falling back to non-embedded sourcemap mode");
  }
  return createClient$1(options);
};
function isVercelPreviewEnvironment() {
  try {
    return import.meta.env.VERCEL_ENV === "preview";
  } catch {}
  try {
    return process.env.VERCEL_ENV === "preview";
  } catch {}
  return false;
}
function detectEnableSourceMap() {
  try {
    return import.meta.env.SANITY_SOURCE_MAP === "true";
  } catch {}
  try {
    return process.env.SANITY_SOURCE_MAP === "true";
  } catch {}
  return false;
}
function detectStudioUrl() {
  try {
    return import.meta.env.SANITY_STUDIO_URL;
  } catch {}
  try {
    return process.env.SANITY_STUDIO_URL;
  } catch {}
}
function mapToEditLinks(response, studioUrl) {
  return mapToEditLinks$1(response.result, response.resultSourceMap, studioUrl);
}
export { createClient, mapToEditLinks };
//# sourceMappingURL=client.js.map
